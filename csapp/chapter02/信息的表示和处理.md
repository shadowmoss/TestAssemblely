* ### 信息存储
大多数计算机使用8位的块，或者字节，作为最小的可寻址的内存单位，而不是访问内存中单独的位。  
机器级程序将内存视为一个分厂大的字节数组，称为虚拟内存，内存中的每个字节都由一个唯一的数字来标识，称为它的地址，所有可能地址的集合就称为虚拟地址空间。  
* #### 寻址和字节顺序
对于跨越多字节的程序对象，我们必须建立两个规则:这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。
* #### 整数表示
描述用位来编码整数的两种不同的方式:一种只能表示非负数，而另外一种能够表示负数、零和整数。  
也就是无符号整数和有符号整数。
###### 无符号整数  
假设有一个整数数据类型有w位。可以得到位向量`[xw-1,xw-2,...,x0]`,  
可以将该位向量看做一个二进制表示的数，就获得了位向量的无符号表示。  
这样的二进制表示的无符号数具体值的计算方法为,B2U = (x0)*2^0+(x1)*2^1+(x2)*2^2+(x3)*2^3+(x4)*2^4+(x5)*2^5+...+(xw-1)2^w-1;  
由**等比数列**的和公式可以得出,一个w二进制位的无符号数的最大值为,(2^w)-1
###### 有符号整数
最常见的有符号数的计算机表示方法就是补码形式。在这个编码中,将二进制位当中的最高有效位解释为负权。  
将二进制位转换为有符号整数的函数,我们用B2T来表示:  
B2T = -x(w-1)*2^(w-1) + (x0)*2^0+(x1)*2^1+(x2)*2^2+(x3)*2^3+(x4)*2^4+(x5)*2^5+...+(xw-2)2^w-2  
###### 无符号数与有符号数之间的转换、有符号数与无符号数之间的转换
无符号数与有符号数之间的转换、有符号数与无符号数据之间的转换,强制类型转换的结果是保持位值不变,  
只是改变了解释这些位的方式。-12345的16位补码与53191的16位表示的二进制表示是完全一样的。  
对于大多数C语言的视线,处理同样字长的有符号数和无符号数之间相互转换的一般规则是:数值可能会变,但是位模式不变。  
用更数学化的形式来描述这个规则。  
有函数U2B(无符号到二进制)、T2B(有符号到二进制)  
1. T2U(有符号到无符号转换):可以得到T2U(x)=B2U(T2B(x)),该函数输入一个TMin~TMax的值,生成x的无符号表示,这里两个数有相同的位模式。
2. U2T(无符号到有符号转换):可以得到U2T(x)=B2T(U2B(x)),该函数输入一个0~UMax之间的值x,生成x的补码表示结果。
3. 同时我们注意到T2U(-12345)=53191,并且U2T(53191)=-12345。同时,(-12345)+53191=65536=2^16,这个属性可以推广到给定位模式的两个数值(补码和无符号数)之间的关系。  
也就是一个w位的补码表示和无符号表示,之间的关系为,-(-T)+U = 2^w。
###### C语言的有符号与无符号表达式的处理
C语言对同时包含有符号和无符号表达式的这种处理方式,出现了一些奇特的行为。当执行一个运算时,如果它的一个运算数是有符号的而另一个是无符号的,  
那么C语言会隐式地将有符号参数强制类型转换为无符号数,并假设两个数都是非负的。
###### 扩展一个数字的位表示
一个无符号数的扩展,为零扩展,因为不会改变原数据的大小。  
一个有符号数的扩展,为符号扩展,即将原数据的最高位有效数,复制进行扩展。同样也不会改变原数据大小。
###### 截断数字