* #### 转移控制
call指令:  
call指令会将当前的下一句指令的地址压入数据栈。  
call Label  Label为被调用的代码段起始位置。  
call *Operand   显示指定需要被调用的代码段的起始位置  
ret指令:  
从栈中将地址之前保存的指令地址弹出,并把PC(程序计数器地址设置为该地址)。  
* #### 溢出缓冲区攻击
当前函数调用使用栈帧保存数据时，数据过长导致超出了分配给定的大小,输入数据覆盖掉了栈帧内容,从而导致函数的ret指令无法获取到正确的返回地址。
* #### 对抗缓冲区溢出攻击
##### 栈随机化
现代Linux操作系统,需要预防程序栈帧的可预测性,所以会在程序开始时,在栈上分配一段0~n字节的随机大小的空间。  
程序不会使用这段空间,但是它会导致程序每次执行时后续栈的位置发生变化。分配的必须足够大,但是又要足够小,不至于浪费太多的程序空间。

但是,也有在攻击代码前,加上一长串的nop指令的操作。构成一个"空操作雪橇",意思是程序会"滑过"这个序列,也就是当程序  
跳转到当前这个"空操作雪橇"的内存区域时,会直接滑向实际的攻击代码开头。(nop指令的含义是,什么都不做,直接指向下一条指令)。
##### 栈破坏检测
GCC在产生的代码中会在局部缓冲区和栈状态之间存储一个特殊的金丝雀值，也被称之为(guard value),程序每次运行时随机产生。  在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个函数的某个操作改变了。  
GCC只在函数中有局部char 类型缓冲区时，才会插入这样的代码。
##### 限制可执行代码区域
虚拟内存在逻辑上被分成了页(page),典型的每页是2048和4096个字节。从前x86体系结构将读和执行访问合并成一个1位的标志，这样任何被标记为刻度的页也都是可执行的。  
栈必须是可读又可写的,因而栈上的字节也都是可执行的。最近AMD和Intel处理器的内存保护引入了"NX"位,将读和执行访问模式分开了。有了这个特性，栈可以被标记为可读和可写，但是不可执行。检查页是否可执行由硬件来完成，效率上没有损失。  
##### 变长栈帧
```c
long vframe(long n,long idx,long *q){
    long i;
    long *p[n];
    p[0] = &i;
    for(i = 1;i < n;i++){
        p[i] = q;
    }
    return *p[idx];
}
```
```asm
vframe:
    pushq %rbp;
    movq %rsp,%rbp;
    subq $16,%rsp
    leaq 22(,%rdi,8),%rax
    andq $-16,%rax
    subq %rax,%rsp
    leaq 7(%rsp),%rax
    shrq $3,%rax
    leaq 0(,%rax,8),%r8
    movq %r8,%rcx
```
`leaq 22(,%rdi,8),%rax`rdi 为传入函数的参数n，用于表示当前数组大小。该操作，用于计算8n+22的地址。`andq $-16,%rax`用于将地址向下取整16的倍数，将%rax值中的低4位清空。